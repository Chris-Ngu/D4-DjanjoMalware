from django.shortcuts import render, redirect,HttpResponse
from .forms import UploadForm
from django.http import JsonResponse, HttpResponse
import pyrebase
import os
from django.conf import settings
from django.core.files.storage import default_storage
from django.core.files.storage import FileSystemStorage
from django.contrib import messages
from pathlib import Path
from malware.settings import BASE_DIR
import pefile
import pprint
import csv
from datetime import datetime

# Test Pefile
import logging

config = {
  "apiKey": "AIzaSyDrjABPNm-8rvKtpTNhFjraofGMN3ajrLw",
    "authDomain": "malwaredetective-c2327.firebaseapp.com",
    "projectId": "malwaredetective-c2327",
    "storageBucket": "malwaredetective-c2327.appspot.com",
    "messagingSenderId": "620692824989",
    "appId": "1:620692824989:web:cfd73f403cc63df046c574",
    "measurementId": "G-E774K8WWQR",
    "databaseURL": ""
}

firebase = pyrebase.initialize_app(config)
storage = firebase.storage()

## Gathering the functions called by the dlls
def func_collect(file_path):
    pe = pefile.PE(file_path)
    dict_func = {}
    for entry in pe.DIRECTORY_ENTRY_IMPORT:

        func_list = []
        dll_name = entry.dll.decode('utf-8')
        # print(dll_name)
        for func in entry.imports:
            # print('\t%s' % func.name.decode('utf-8'))
            func_name = func.name.decode('utf-8')
            func_list.append(func_name)

        dict_func[dll_name] = func_list
## returns a dictionary with the key values being the dll names and the values are a list of functions
    return(dict_func)

def getTimeDateStamp(file_path):
    pe=pefile.PE(file_path)
    return hex(pe.FILE_HEADER.TimeDateStamp)

def getNumberOfDllUsed(dll_dict):
    return len(dll_dict)

def view_name(request):
    file_name = ""
    file_numberOfSections = ""
    file_DllChar =""
    dll_types = []
    dll_dict = {}
    file_ImageVersion = ""
    compileTimeInHex=""
    compileTime= ""
    dt_object=""
    virtual_memory = 0
    physical_memory = 0
    fileSize = ""
    severity = ""
    section_count = ""
    version = ""
    numberOfDll= 0
    dict_func=""


    
    # CSV download
    # https://docs.djangoproject.com/en/3.1/howto/outputting-csv/
    # For some reason, I can't use the bottom comment
    # if requst.method == 'POST' and 'CSV' in request.POST:
    if request.method == 'POST' and "myfile" not in request.FILES:
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = 'attachment; filename="report.csv"'
        writer = csv.writer(response)
        
        # Insert features here for file
        writer.writerow(["first row", "some", "value"])
        writer.writerow(["second row", "some", "value"])
        return response

    elif request.method == 'POST' and 'myfile' in request.FILES:
        
        # open temp.txt and erase temp data
        file = open("temp.txt","r+")
        file.truncate(0)
        file.close()
        
        file = request.FILES['myfile']
        fs = FileSystemStorage()
        file_save = fs.save(file.name, file)
        
        # comment out this code below to enable storing file in firebase storage
        # storage.child("files/" + file.name).put("media/" + file.name)
        fileSize = str(file.size)
        print("Uploaded file name: "+file.name)
        print("Uploaded file size: "+fileSize)
        
        #LOGGIN DEBUG
        # logger.info(file_path)
        logger = logging.getLogger('testlogger')

        #Test pefile
        file_name = file.name
        file_path = os.path.join(BASE_DIR, 'media/'+file.name)
        putty = pefile.PE(file_path)

        # FILE_HEADER
        machine = putty.FILE_HEADER.Machine
        timeDateStamp = putty.FILE_HEADER.TimeDateStamp
        section_count =  putty.FILE_HEADER.NumberOfSections
        characteristic = putty.FILE_HEADER.Characteristics

        #OPTIONAL_HEADER
        magic = putty.OPTIONAL_HEADER.Magic
        dll = putty.OPTIONAL_HEADER.DllCharacteristics
        version = putty.OPTIONAL_HEADER.MajorImageVersion
        addressOfEntry = putty.OPTIONAL_HEADER.Magic
        severity = "HIGH"

        for entry in putty.DIRECTORY_ENTRY_IMPORT:
            dll_types.append(entry.dll.decode('utf-8'))
        dll_dict['dll_types'] = dll_types


        ##------------------- All possible value needed to return to homepage ------------------##
        numberOfDll = getNumberOfDllUsed(dll_dict['dll_types'])


        ##### ---------------- store all data in temp text file to export to csv file -------- #########
        file1 = open("temp.txt","a")
        L = ["File_name: "+file_name+"\n","Number of Section: "+str(section_count)+"\n"] 
        # \n is placed to indicate EOL (End of Line)
        file1.writelines(L)
        file1.close()
        ##### ----------------end-------- #########
       

        # ------- Get Compile Time -----------
        compileTimeInHex = getTimeDateStamp(file_path)
        # convert hex to decimal string
        compileTimeInDec = int(compileTimeInHex, 16)
        logger.info(compileTimeInDec)
        compileTime = datetime.fromtimestamp(compileTimeInDec).strftime('%Y-%m-%d %H:%M:%S')
        logger.info(compileTime)
        #-------- Function Collecting ----------
        #returns a dictionary of dlls as keys with values being a list of functions called.
        #def func_collect is near the top
        dict_func = func_collect(file_path)
        # pprint.pprint(dict_func)
        
        # messages.success(request, "File upload in Firebase Storage successful")
    #return render(request, "fileUpload/home.html",{"FileName":file_name,"NumberOfSection":file_numberOfSections,"DllChar":file_DllChar,"ImageVersion":file_ImageVersion})   
    
    return render(request, "fileUpload/home.html",{
        "CompileTimeInHex":compileTimeInHex,
        "CompileTime":compileTime, 
        "FileName": file_name,
        "virtual_memory": virtual_memory,
        "physical_memory": physical_memory,
        "file_size": fileSize,
        "severity": severity,
        "file_section_count": section_count,
        "file_version": version,
        'NumberOfDlls':numberOfDll,
        'FunctionCalls':dict_func
        })
