from django.shortcuts import render, redirect,HttpResponse
from .forms import UploadForm
from django.http import JsonResponse, HttpResponse
import pyrebase
import os
from django.conf import settings
from django.core.files.storage import default_storage
from django.core.files.storage import FileSystemStorage
from django.contrib import messages
from pathlib import Path
from malware.settings import BASE_DIR
import pefile
import pprint
import csv
from datetime import datetime

# Test Pefile
import logging

config = {
  "apiKey": "AIzaSyDrjABPNm-8rvKtpTNhFjraofGMN3ajrLw",
    "authDomain": "malwaredetective-c2327.firebaseapp.com",
    "projectId": "malwaredetective-c2327",
    "storageBucket": "malwaredetective-c2327.appspot.com",
    "messagingSenderId": "620692824989",
    "appId": "1:620692824989:web:cfd73f403cc63df046c574",
    "measurementId": "G-E774K8WWQR",
    "databaseURL": ""
}

firebase = pyrebase.initialize_app(config)
storage = firebase.storage()


## Gathering the functions called by the dlls
def func_collect(file_path):
    pe = pefile.PE(file_path)
    dict_func = {}
    for entry in pe.DIRECTORY_ENTRY_IMPORT:

        func_list = []
        dll_name = entry.dll.decode('utf-8')
        # print(dll_name)
        for func in entry.imports:
            # print('\t%s' % func.name.decode('utf-8'))
            func_name = func.name.decode('utf-8')
            func_list.append(func_name)

        dict_func[dll_name] = func_list
## returns a dictionary with the key values being the dll names and the values are a list of functions
    return(dict_func)

def getTimeDateStamp(file_path):
    pe=pefile.PE(file_path)
    return hex(pe.FILE_HEADER.TimeDateStamp)

def view_name(request):
    file_name = ""
    file_numberOfSections = ""
    file_DllChar =""
    file_ImageVersion = ""
    compileTimeInHex=""
    compileTime= ""
    dt_object=""
    dict_func=""
    
    # CSV download
    # https://docs.djangoproject.com/en/3.1/howto/outputting-csv/
    # For some reason, I can't use the bottom comment
    # if requst.method == 'POST' and 'CSV' in request.POST:

    if request.method == 'POST' and "myfile" not in request.FILES:
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = 'attachment; filename="report.csv"'
        writer = csv.writer(response)
        
        # Insert features here for file
        writer.writerow(["first row", "some", file_name])
        writer.writerow(["second row", "some", file_numberOfSections])
        return response

    elif request.method == 'POST' and 'myfile' in request.FILES:
        
        # open temp.txt and erase temp data
        file = open("temp.txt","r+")
        file.truncate(0)
        file.close()
        
        
        file = request.FILES['myfile']
        fs = FileSystemStorage()
        file_save = fs.save(file.name, file)
        uploaded_file_url = fs.url(file_save)
        print(uploaded_file_url)
        # storage.child("files/" + file.name).put("media/" + file.name)
        print("Uploaded file name: "+file.name)
        print("Uploaded file size: "+str(file.size))
        
        #LOGGIN DEBUG
        logger = logging.getLogger('testlogger')

        #Test pefile
        file_name = file.name
        file_path = os.path.join(BASE_DIR, 'media/'+file.name)
        putty = pefile.PE(file_path)
        sections =  putty.FILE_HEADER.NumberOfSections
        dll = putty.OPTIONAL_HEADER.DllCharacteristics
        ver = putty.OPTIONAL_HEADER.MajorImageVersion
        
        # Adding .DLL types
        dll_dict = {}
        # dll_files = []
        dll_types = []
        for entry in putty.DIRECTORY_ENTRY_IMPORT:
            dll_types.append(entry.dll.decode('utf-8'))
        dll_dict['dll_types'] = dll_types
        
        ##### ---------------- store all data in temp text file to export to csv file -------- #########
        file1 = open("temp.txt","a")
        L = ["File_name: "+file_name+"\n","Number of Section: "+str(sections)+"\n"] 
        # \n is placed to indicate EOL (End of Line)
        file1.writelines(L)
        file1.close()
        ##### ----------------end-------- #########

        # logger.info(file_path)
        # file_numberOfSections = "\n Number of Sections:" + str(sections)
        # file_DllChar ="\n Dynamic : "+str(dll)
        # file_ImageVersion = "\n Image Version: "+str(ver)

        # ------- Get Compile Time -----------
        compileTimeInHex = getTimeDateStamp(file_path)
        # convert hex to decimal string
        compileTimeInDec = int(compileTimeInHex, 16)
        logger.info(compileTimeInDec)
        compileTime = datetime.fromtimestamp(compileTimeInDec).strftime('%Y-%m-%d %H:%M:%S')
        logger.info(compileTime)
        # file_info
        messages.success(request, "File upload in Firebase Storage successful")

        #-------- Function Collecting ----------
        #returns a dictionary of dlls as keys with values being a list of functions called.
        #def func_collect is near the top
        dict_func = func_collect(file_path)
        # pprint.pprint(dict_func)

    #return render(request, "fileUpload/home.html",{"FileName":file_name,"NumberOfSection":file_numberOfSections,"DllChar":file_DllChar,"ImageVersion":file_ImageVersion})   
    return render(request, "fileUpload/home.html",{"CompileTimeInHex":compileTimeInHex,"CompileTime":compileTime, "FunctionCalls":dict_func})
